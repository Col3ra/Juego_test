<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Amigos Kombat</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        body { background-color: #000; margin: 0; height: 100vh; width: 100vw; overflow: hidden; font-family: 'Press Start 2P', cursive; color: white; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: #1a1a1a; }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        .top-bar { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: space-between; width: 90%; max-width: 600px; }
        .health-wrapper { width: 40%; }
        .player-name { font-size: 10px; margin-bottom: 4px; text-shadow: 2px 2px 0 #000; }
        .health-bar-container { width: 100%; height: 15px; background: #555; border: 2px solid #fff; }
        .health-bar { height: 100%; background: #4ade80; transition: width 0.1s linear; }
        #enemyHealth { background: #f87171; float: right; }
        .timer { width: 30px; height: 30px; background: #222; border: 2px solid #fff; display: flex; justify-content: center; align-items: center; font-size: 14px; }
        .overlay-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 30px; display: none; z-index: 20; text-shadow: 3px 3px 0 #000; text-align: center; width: 100%; }

        #character-select { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #121212; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #character-select h2 { margin-bottom: 15px; font-size: 16px; color: #e94560; }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .char-card { background: #222; border: 2px solid #444; padding: 10px; border-radius: 8px; text-align: center; cursor: pointer; }
        .char-preview { width: 50px; height: 50px; background-size: 400%; background-position: 0 0; border-radius: 50%; margin: 0 auto 5px auto; background-color: #000; }

        #mobile-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .control-area-left { position: absolute; bottom: 20px; left: 20px; width: 160px; height: 160px; pointer-events: auto; }
        .control-area-right { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 160px; pointer-events: auto; }
        .btn { width: 65px; height: 65px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.4); border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; }
        .btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }
        #btn-left { bottom: 10px; left: 0; }
        #btn-right { bottom: 10px; left: 80px; }
        #btn-attack { bottom: 20px; right: 80px; width: 75px; height: 75px; background: rgba(255,0,0,0.2); border-color: #e94560; }
        #btn-jump { bottom: 40px; right: 0; }
        #loading-msg { color: #888; font-size: 10px; margin-top: 10px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="character-select">
        <h2>SELECCIONA LUCHADOR</h2>
        <p id="select-instruction" style="color:#aaa; font-size:10px;">Jugador 1</p>
        <div class="grid" id="char-grid" style="display:none;"></div>
        <div id="loading-msg">Procesando Sprites...</div>
    </div>

    <div class="ui-layer" id="game-ui">
        <div class="top-bar">
            <div class="health-wrapper">
                <div class="player-name" id="p1-name">P1</div>
                <div class="health-bar-container"><div class="health-bar" id="playerHealth"></div></div>
            </div>
            <div class="timer" id="timer">60</div>
            <div class="health-wrapper" style="align-items: flex-end; text-align: right;">
                <div class="player-name" id="p2-name">P2</div>
                <div class="health-bar-container"><div class="health-bar" id="enemyHealth"></div></div>
            </div>
        </div>
    </div>

    <div class="overlay-text" id="displayText">
        <span id="winnerText">GANADOR</span>
        <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Toca para reiniciar</div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="mobile-controls">
        <div class="control-area-left">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-right">→</div>
        </div>
        <div class="control-area-right">
            <div class="btn" id="btn-attack">⚔️</div>
            <div class="btn" id="btn-jump">↑</div>
        </div>
    </div>
</div>

<script>
    // --- CALIBRACIÓN ---
    const GLOBAL_SCALE = 0.75; // Escala un poco más pequeña para que quepan bien
    
    // OFFSET PARA CENTRAR Y BAJAR AL PISO
    // Y: -95 baja bastante el sprite para que los pies toquen la línea negra del suelo.
    // X: 135 centra el sprite horizontalmente en su caja.
    const OFFSET = { x: 135, y: -95 };

    const CHARACTERS_CONFIG = {
        juan:  { name: "Juan",  src: "./images/juan.png",  scale: GLOBAL_SCALE, offset: OFFSET },
        fran:  { name: "Fran",  src: "./images/fran.png",  scale: GLOBAL_SCALE, offset: OFFSET },
        fede:  { name: "Fede",  src: "./images/fede.png",  scale: GLOBAL_SCALE, offset: OFFSET },
        rodri: { name: "Rodri", src: "./images/rodri.png", scale: GLOBAL_SCALE, offset: OFFSET }
    };

    // CHROMA KEY (Filtro de fondo negro)
    const processedImages = {};
    function removeBackground(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = src;
            img.onload = () => {
                const c = document.createElement('canvas');
                const ctx = c.getContext('2d');
                c.width = img.width; c.height = img.height;
                ctx.drawImage(img, 0, 0);
                const id = ctx.getImageData(0, 0, c.width, c.height);
                const d = id.data;
                // Filtro suave: Solo borra negro muy puro para no romper la ropa
                for (let i = 0; i < d.length; i += 4) {
                    if (d[i] < 30 && d[i+1] < 30 && d[i+2] < 30) d[i+3] = 0;
                }
                ctx.putImageData(id, 0, 0);
                const newImg = new Image();
                newImg.src = c.toDataURL();
                resolve(newImg);
            };
            img.onerror = () => resolve(new Image());
        });
    }

    async function loadAssets() {
        const promises = Object.keys(CHARACTERS_CONFIG).map(async k => {
            processedImages[k] = await removeBackground(CHARACTERS_CONFIG[k].src);
        });
        await Promise.all(promises);
        initMenu();
    }

    // MOTOR
    const canvas = document.querySelector('canvas');
    const c = canvas.getContext('2d');
    canvas.width = 1024; canvas.height = 576;
    const gravity = 0.6;

    function drawBackground() {
        // Cielo
        let g = c.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, "#0f0c29"); g.addColorStop(1, "#302b63");
        c.fillStyle = g; c.fillRect(0, 0, canvas.width, canvas.height);
        
        // Estrellas estáticas (para rendimiento y evitar parpadeo de fondo)
        if(!window.stars) {
            window.stars = Array(50).fill().map(() => ({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height, s: Math.random() * 2
            }));
        }
        c.fillStyle = "rgba(255,255,255,0.6)";
        window.stars.forEach(st => c.fillRect(st.x, st.y, st.s, st.s));

        // Suelo
        c.fillStyle = "#1a1a1a"; c.fillRect(0, canvas.height - 80, canvas.width, 80);
        c.fillStyle = "#333"; c.fillRect(0, canvas.height - 80, canvas.width, 4);
    }

    class Fighter {
        constructor({ position, velocity, image, scale, offset, name, direction = 1 }) {
            this.position = position;
            this.velocity = velocity;
            this.image = image;
            this.scale = scale;
            this.offset = offset;
            this.name = name;
            this.direction = direction;
            
            this.width = 50; this.height = 150;
            
            // CONFIGURACIÓN INICIAL
            this.framesMax = 4; // Empezamos con Idle que tiene 4
            this.framesCurrent = 0;
            this.framesElapsed = 0;
            this.framesHold = 10; // Idle lento
            this.rows = 5; 
            this.currentRow = 0; 
            
            this.attackBox = { position: {x:0, y:0}, width: 120, height: 50 };
            this.isAttacking = false;
            this.health = 100;
            this.dead = false;
        }

        draw() {
            if(!this.image) return;

            // --- CORRECCIÓN CRÍTICA DE LÓGICA ---
            // Volvemos a usar this.framesMax para el cálculo.
            // Cuando esté quieto (Idle), framesMax será 4 -> divide ancho por 4 -> Sprite ancho correcto.
            // Cuando camine (Run), framesMax será 8 -> divide ancho por 8 -> Sprite angosto correcto.
            const frameWidth = this.image.width / this.framesMax;
            const frameHeight = this.image.height / this.rows;

            const renderW = frameWidth * this.scale;
            const renderH = frameHeight * this.scale;
            const drawX = this.position.x - this.offset.x;
            const drawY = this.position.y + this.height - renderH - this.offset.y;

            c.save();
            c.translate(this.position.x + this.width/2, this.position.y + this.height/2);
            c.scale(this.direction, 1);
            c.translate(-(this.position.x + this.width/2), -(this.position.y + this.height/2));

            c.drawImage(
                this.image,
                this.framesCurrent * frameWidth, // X en la imagen fuente
                this.currentRow * frameHeight,   // Y en la imagen fuente
                frameWidth,                      // Ancho a recortar
                frameHeight,                     // Alto a recortar
                drawX, drawY, renderW, renderH   // Dónde y qué tamaño dibujar en canvas
            );
            c.restore();
        }

        update() {
            this.draw();
            if(!this.dead) {
                this.framesElapsed++;
                if(this.framesElapsed % this.framesHold === 0) {
                    if(this.framesCurrent < this.framesMax - 1) {
                        this.framesCurrent++;
                    } else {
                        this.framesCurrent = 0;
                    }
                }
            }

            const atkOffset = this.direction === 1 ? this.width : -this.attackBox.width;
            this.attackBox.position.x = this.position.x + atkOffset;
            this.attackBox.position.y = this.position.y + 40;

            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            if (this.position.y + this.height + this.velocity.y >= canvas.height - 80) {
                this.velocity.y = 0;
                this.position.y = canvas.height - 80 - this.height;
            } else {
                this.velocity.y += gravity;
            }

            if(this.position.x < 0) this.position.x = 0;
            if(this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;
        }

        attack() { this.switchSprite(2); this.isAttacking = true; }
        takeHit() { this.health -= 10; if(this.health <= 0) this.switchSprite(4, true); else this.switchSprite(4); }

        switchSprite(row, isDead = false) {
            if(this.currentRow === 4 && this.framesCurrent < this.framesMax - 1 && !this.dead) return;
            if(this.currentRow === 2 && this.framesCurrent < this.framesMax - 1) return;
            if(this.dead) return;

            if(this.currentRow !== row) {
                this.currentRow = row;
                this.framesCurrent = 0;
                
                // --- MAPEO CORRECTO DE FRAMES SEGÚN TUS IMÁGENES ---
                // Fila 0 (Idle): Tiene 4 dibujos.
                // Fila 1 (Run): Tiene 8 dibujos.
                // Fila 2 (Punch): Tiene 4 dibujos (basado en lo que veo, si se ve mal prueba con 6).
                // Fila 4 (Hurt/Dead): Tiene 3 dibujos.
                
                if(row === 0) { 
                    this.framesMax = 4; 
                    this.framesHold = 10; 
                }
                if(row === 1) { 
                    this.framesMax = 5; 
                    this.framesHold = 5; 
                }
                if(row === 2) { 
                    this.framesMax = 3; // Ajustado a 4 según inspección visual
                    this.framesHold = 5; 
                }
                if(row === 4) { 
                    this.framesMax = 3; 
                    if(isDead) this.dead = true; 
                }
            }
        }
    }

    let player, enemy, timer = 60, timerId, gameRunning = false;
    const keys = { a: {pressed:false}, d: {pressed:false}, ArrowLeft: {pressed:false}, ArrowRight: {pressed:false} };

    function initMenu() {
        document.getElementById('loading-msg').style.display = 'none';
        const grid = document.getElementById('char-grid');
        grid.style.display = 'grid';
        Object.keys(CHARACTERS_CONFIG).forEach(key => {
            const char = CHARACTERS_CONFIG[key];
            const div = document.createElement('div');
            div.className = 'char-card';
            const pc = document.createElement('canvas');
            pc.width=50; pc.height=50;
            const pctx = pc.getContext('2d');
            // Preview: Usamos width/4 para Idle que es la primera fila
            const fw = processedImages[key].width / 4; 
            pctx.drawImage(processedImages[key], 0, 0, fw, fw, 0, 0, 200, 200); 
            div.innerHTML = `<div class="char-preview" style="background-image:url(${pc.toDataURL()})"></div><span>${char.name}</span>`;
            div.onclick = () => selectChar(key);
            grid.appendChild(div);
        });
    }

    let p1Sel = null;
    function selectChar(k) {
        if(!p1Sel) {
            p1Sel = k;
            document.getElementById('select-instruction').innerText = "JUGADOR 2";
        } else {
            document.getElementById('character-select').style.display = 'none';
            startGame(p1Sel, k);
        }
    }

    function startGame(k1, k2) {
        document.getElementById('game-ui').style.display = 'block';
        document.getElementById('mobile-controls').style.display = 'block';
        const c1 = CHARACTERS_CONFIG[k1];
        const c2 = CHARACTERS_CONFIG[k2];

        document.getElementById('p1-name').innerText = c1.name;
        document.getElementById('p2-name').innerText = c2.name;

        player = new Fighter({
            position: {x: 200, y: 0}, velocity: {x:0, y:0},
            image: processedImages[k1], scale: c1.scale, offset: c1.offset, name: c1.name, direction: 1
        });
        enemy = new Fighter({
            position: {x: 800, y: 0}, velocity: {x:0, y:0},
            image: processedImages[k2], scale: c2.scale, offset: c2.offset, name: c2.name, direction: -1
        });

        gameRunning = true;
        decreaseTimer();
        animate();
    }

    function decreaseTimer() {
        if(timer>0 && gameRunning) {
            timerId = setTimeout(decreaseTimer, 1000);
            timer--;
            document.querySelector('.timer').innerText = timer;
        }
        if(timer===0) endGame();
    }

    function rectCol(r1, r2) {
        return (r1.attackBox.position.x + r1.attackBox.width >= r2.position.x &&
                r1.attackBox.position.x <= r2.position.x + r2.width &&
                r1.attackBox.position.y + r1.attackBox.height >= r2.position.y &&
                r1.attackBox.position.y <= r2.position.y + r2.height);
    }

    function endGame() {
        gameRunning = false;
        clearTimeout(timerId);
        document.getElementById('displayText').style.display = 'block';
        const txt = document.getElementById('winnerText');
        if(player.health === enemy.health) txt.innerText = "EMPATE";
        else if(player.health > enemy.health) txt.innerText = "P1 GANA";
        else txt.innerText = "P2 GANA";
    }

    function animate() {
        if(!gameRunning) return;
        window.requestAnimationFrame(animate);
        c.clearRect(0,0,canvas.width, canvas.height);
        drawBackground();

        if(player && enemy) {
            player.direction = player.position.x <= enemy.position.x ? 1 : -1;
            enemy.direction = enemy.position.x >= player.position.x ? -1 : 1;
        }

        player.update();
        enemy.update();

        player.velocity.x = 0;
        if(keys.a.pressed) { player.velocity.x = -5; player.switchSprite(1); }
        else if(keys.d.pressed) { player.velocity.x = 5; player.switchSprite(1); }
        else player.switchSprite(0);

        enemy.velocity.x = 0;
        if(keys.ArrowLeft.pressed) { enemy.velocity.x = -5; enemy.switchSprite(1); }
        else if(keys.ArrowRight.pressed) { enemy.velocity.x = 5; enemy.switchSprite(1); }
        else enemy.switchSprite(0);

        if(rectCol(player, enemy) && player.isAttacking && player.framesCurrent===2) {
            enemy.takeHit();
            player.isAttacking = false;
            document.getElementById('enemyHealth').style.width = enemy.health + '%';
        }
        if(player.isAttacking && player.framesCurrent===2) player.isAttacking=false;

        if(rectCol(enemy, player) && enemy.isAttacking && enemy.framesCurrent===2) {
            player.takeHit();
            enemy.isAttacking = false;
            document.getElementById('playerHealth').style.width = player.health + '%';
        }
        if(enemy.isAttacking && enemy.framesCurrent===2) enemy.isAttacking=false;

        if(player.health<=0 || enemy.health<=0) endGame();
    }

    window.addEventListener('keydown', e => {
        if(!gameRunning) return;
        switch(e.key) {
            case 'd': keys.d.pressed=true; break;
            case 'a': keys.a.pressed=true; break;
            case 'w': if(player.velocity.y===0) player.velocity.y = -15; break;
            case ' ': player.attack(); break;
            case 'ArrowRight': keys.ArrowRight.pressed=true; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed=true; break;
            case 'ArrowUp': if(enemy.velocity.y===0) enemy.velocity.y = -15; break;
            case 'ArrowDown': enemy.attack(); break;
        }
    });
    window.addEventListener('keyup', e => {
        switch(e.key) {
            case 'd': keys.d.pressed=false; break;
            case 'a': keys.a.pressed=false; break;
            case 'ArrowRight': keys.ArrowRight.pressed=false; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed=false; break;
        }
    });

    const setupTouch = (id, action, val) => {
        const btn = document.getElementById(id);
        btn.addEventListener('touchstart', e => {
            e.preventDefault();
            if(!gameRunning) return;
            if(action === 'move') keys[val].pressed = true;
            if(action === 'jump') { if(player.velocity.y===0) player.velocity.y = -15; }
            if(action === 'attack') player.attack();
        });
        btn.addEventListener('touchend', e => {
            e.preventDefault();
            if(action === 'move') keys[val].pressed = false;
        });
    };

    setupTouch('btn-left', 'move', 'a');
    setupTouch('btn-right', 'move', 'd');
    setupTouch('btn-jump', 'jump');
    setupTouch('btn-attack', 'attack');

    window.addEventListener('click', () => { if(!gameRunning && player) location.reload(); });

    loadAssets();
</script>
</body>
</html>


