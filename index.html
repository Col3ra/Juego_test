<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Amigos Kombat</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        body { background-color: #000; margin: 0; height: 100vh; width: 100vw; overflow: hidden; font-family: 'Press Start 2P', cursive; color: white; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: #1a1a1a; }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        
        /* UI */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        .top-bar { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: space-between; width: 90%; max-width: 600px; }
        .health-wrapper { width: 40%; }
        .player-name { font-size: 10px; margin-bottom: 4px; text-shadow: 2px 2px 0 #000; }
        .health-bar-container { width: 100%; height: 15px; background: #555; border: 2px solid #fff; }
        .health-bar { height: 100%; background: #4ade80; transition: width 0.1s linear; } /* Transición más rápida para golpes */
        #enemyHealth { background: #f87171; float: right; }
        .timer { width: 30px; height: 30px; background: #222; border: 2px solid #fff; display: flex; justify-content: center; align-items: center; font-size: 14px; }
        .overlay-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 30px; display: none; z-index: 20; text-shadow: 3px 3px 0 #000; text-align: center; width: 100%; }

        /* Menu */
        #character-select { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #121212; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #character-select h2 { margin-bottom: 15px; font-size: 16px; color: #e94560; }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .char-card { background: #222; border: 2px solid #444; padding: 10px; border-radius: 8px; text-align: center; cursor: pointer; }
        .char-preview { width: 50px; height: 50px; background-size: 400%; background-position: 0 0; border-radius: 50%; margin: 0 auto 5px auto; background-color: #000; }
        
        /* Controls */
        #mobile-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        .control-area-left { position: absolute; bottom: 20px; left: 20px; width: 160px; height: 160px; pointer-events: auto; }
        .control-area-right { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 160px; pointer-events: auto; }
        .btn { width: 65px; height: 65px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.4); border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: 24px; color: white; }
        .btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }
        #btn-left { bottom: 10px; left: 0; }
        #btn-right { bottom: 10px; left: 80px; }
        #btn-attack { bottom: 20px; right: 80px; width: 75px; height: 75px; background: rgba(255,0,0,0.2); border-color: #e94560; }
        #btn-jump { bottom: 40px; right: 0; }
        #loading-msg { color: #888; font-size: 10px; margin-top: 10px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="character-select">
        <h2>SELECCIONA LUCHADOR</h2>
        <p id="select-instruction" style="color:#aaa; font-size:10px;">Jugador 1</p>
        <div class="grid" id="char-grid" style="display:none;"></div>
        <div id="loading-msg">Procesando Sprites...</div>
    </div>

    <div class="ui-layer" id="game-ui">
        <div class="top-bar">
            <div class="health-wrapper">
                <div class="player-name" id="p1-name">P1</div>
                <div class="health-bar-container"><div class="health-bar" id="playerHealth"></div></div>
            </div>
            <div class="timer" id="timer">60</div>
            <div class="health-wrapper" style="align-items: flex-end; text-align: right;">
                <div class="player-name" id="p2-name">P2</div>
                <div class="health-bar-container"><div class="health-bar" id="enemyHealth"></div></div>
            </div>
        </div>
    </div>

    <div class="overlay-text" id="displayText">
        <span id="winnerText">GANADOR</span>
        <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Toca para reiniciar</div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="mobile-controls">
        <div class="control-area-left">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-right">→</div>
        </div>
        <div class="control-area-right">
            <div class="btn" id="btn-attack">⚔️</div>
            <div class="btn" id="btn-jump">↑</div>
        </div>
    </div>
</div>

<script>
    // --- AJUSTES DE POSICIÓN Y TAMAÑO ---
    const GLOBAL_SCALE = 0.85; 

    // FIX: El offset.y controla qué tan abajo se dibuja la imagen respecto a la caja de colisión.
    // Si flotan, aumenta el valor de 'y' negativo (o disminuye el positivo dependiendo de la lógica).
    // Aquí usamos valores negativos para "bajar" el dibujo visualmente hacia el suelo.
    const Y_OFFSET_FIX = -55; 
    const X_OFFSET_FIX = 130; // Centrar sprite en la hitbox

    const CHARACTERS_CONFIG = {
        juan:  { name: "Juan",  src: "./images/juan.png",  scale: GLOBAL_SCALE, offset: { x: X_OFFSET_FIX, y: Y_OFFSET_FIX } },
        fran:  { name: "Fran",  src: "./images/fran.png",  scale: GLOBAL_SCALE, offset: { x: X_OFFSET_FIX, y: Y_OFFSET_FIX } },
        fede:  { name: "Fede",  src: "./images/fede.png",  scale: GLOBAL_SCALE, offset: { x: X_OFFSET_FIX, y: Y_OFFSET_FIX } },
        rodri: { name: "Rodri", src: "./images/rodri.png", scale: GLOBAL_SCALE, offset: { x: X_OFFSET_FIX, y: Y_OFFSET_FIX } }
    };

    // --- PROCESAMIENTO DE IMAGEN (CHROMA KEY) ---
    const processedImages = {};
    function removeBackground(src) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = src;
            img.onload = () => {
                const c = document.createElement('canvas');
                const ctx = c.getContext('2d');
                c.width = img.width; c.height = img.height;
                ctx.drawImage(img, 0, 0);
                const id = ctx.getImageData(0, 0, c.width, c.height);
                const d = id.data;
                for (let i = 0; i < d.length; i += 4) {
                    if (d[i] < 50 && d[i+1] < 50 && d[i+2] < 50) d[i+3] = 0;
                }
                ctx.putImageData(id, 0, 0);
                const newImg = new Image();
                newImg.src = c.toDataURL();
                resolve(newImg);
            };
            img.onerror = () => resolve(new Image());
        });
    }

    async function loadAssets() {
        const promises = Object.keys(CHARACTERS_CONFIG).map(async k => {
            processedImages[k] = await removeBackground(CHARACTERS_CONFIG[k].src);
        });
        await Promise.all(promises);
        initMenu();
    }

    // --- MOTOR ---
    const canvas = document.querySelector('canvas');
    const c = canvas.getContext('2d');
    canvas.width = 1024; canvas.height = 576;
    const gravity = 0.6;

    // Estrellas
    const stars = Array(40).fill().map(() => ({
        x: Math.random() * canvas.width, y: Math.random() * canvas.height,
        s: Math.random() * 2, v: Math.random() * 0.5 + 0.1
    }));

    function drawBackground() {
        let g = c.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, "#0f0c29"); g.addColorStop(1, "#302b63");
        c.fillStyle = g; c.fillRect(0, 0, canvas.width, canvas.height);
        c.fillStyle = "rgba(255,255,255,0.6)";
        stars.forEach(st => {
            c.fillRect(st.x, st.y, st.s, st.s);
            st.x -= st.v; if(st.x < 0) st.x = canvas.width;
        });
        // Suelo visual
        c.fillStyle = "#1a1a1a"; c.fillRect(0, canvas.height - 80, canvas.width, 80);
        c.fillStyle = "#333"; c.fillRect(0, canvas.height - 80, canvas.width, 4);
    }

    class Fighter {
        constructor({ position, velocity, image, scale, offset, name, direction = 1 }) {
            this.position = position;
            this.velocity = velocity;
            this.image = image;
            this.scale = scale;
            this.offset = offset; 
            this.name = name;
            this.direction = direction; 
            
            this.width = 50; 
            this.height = 150; 
            
            // --- FIX CRÍTICO DE ANIMACIÓN ---
            // La hoja de sprites generada tiene 8 columnas de ancho total.
            // Siempre debemos dividir el ancho de la imagen por 8, 
            // independientemente de cuántos frames use la animación actual.
            this.sheetColumns = 8; 

            this.framesMax = 4; 
            this.framesCurrent = 0;
            this.framesElapsed = 0;
            this.framesHold = 6; // Más rápido para fluidez
            this.rows = 5; 
            this.currentRow = 0; 
            
            this.lastKey;
            this.attackBox = { position: {x:0, y:0}, width: 120, height: 50 };
            this.isAttacking = false;
            this.health = 100;
            this.dead = false;
        }

        draw() {
            if(!this.image) return;

            // --- FIX DE PERSIANA ---
            // Usamos this.sheetColumns (8) en lugar de this.framesMax
            const fw = this.image.width / this.sheetColumns; 
            const fh = this.image.height / this.rows;

            const renderW = fw * this.scale;
            const renderH = fh * this.scale;
            
            // --- FIX DE FLOTAR ---
            // Dibujamos relativo a la posición + el offset configurado
            const drawX = this.position.x - this.offset.x;
            const drawY = this.position.y - this.offset.y; 

            c.save();
            // Punto de pivote para invertir dirección (espejo)
            c.translate(this.position.x + this.width/2, this.position.y + this.height/2);
            c.scale(this.direction, 1);
            c.translate(-(this.position.x + this.width/2), -(this.position.y + this.height/2));

            c.drawImage(
                this.image,
                this.framesCurrent * fw, this.currentRow * fh, fw, fh,
                drawX, drawY,
                renderW, renderH
            );
            c.restore();
            
            // DEBUG: Descomenta esto para ver la caja roja de colisión real
            // c.fillStyle = 'rgba(255, 0, 0, 0.3)';
            // c.fillRect(this.position.x, this.position.y, this.width, this.height);
        }

        update() {
            this.draw();
            if(!this.dead) {
                this.framesElapsed++;
                if(this.framesElapsed % this.framesHold === 0) {
                    if(this.framesCurrent < this.framesMax - 1) this.framesCurrent++;
                    else this.framesCurrent = 0;
                }
            }

            // Attack box logic
            const atkOffset = this.direction === 1 ? 0 : -this.attackBox.width + this.width;
            this.attackBox.position.x = this.position.x + atkOffset;
            this.attackBox.position.y = this.position.y + 40;

            this.position.x += this.velocity.x;
            this.position.y += this.velocity.y;

            // Suelo (Hitbox se detiene en el piso)
            // El piso visual está en canvas.height - 80
            if (this.position.y + this.height + this.velocity.y >= canvas.height - 80) {
                this.velocity.y = 0;
                this.position.y = canvas.height - 80 - this.height;
            } else {
                this.velocity.y += gravity;
            }

            // Paredes
            if(this.position.x < 0) this.position.x = 0;
            if(this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;
        }

        attack() { this.switchSprite(2); this.isAttacking = true; }
        takeHit() { 
            this.health -= 10; 
            if(this.health <= 0) this.switchSprite(4, true); 
            else this.switchSprite(4); 
        }

        switchSprite(row, isDead = false) {
            if(this.currentRow === 4 && this.framesCurrent < this.framesMax - 1 && !this.dead) return;
            if(this.currentRow === 2 && this.framesCurrent < this.framesMax - 1) return;
            if(this.dead) return;

            if(this.currentRow !== row) {
                this.currentRow = row;
                this.framesCurrent = 0;
                if(row === 0) this.framesMax = 4; // Idle
                if(row === 1) this.framesMax = 8; // Run
                if(row === 2) this.framesMax = 4; // Punch
                if(row === 4) {
                    this.framesMax = 3; 
                    if(isDead) this.dead = true;
                }
            }
        }
    }

    let player, enemy, timer = 60, timerId, gameRunning = false;
    const keys = { a: {pressed:false}, d: {pressed:false}, ArrowLeft: {pressed:false}, ArrowRight: {pressed:false} };

    function initMenu() {
        document.getElementById('loading-msg').style.display = 'none';
        const grid = document.getElementById('char-grid');
        grid.style.display = 'grid';
        
        Object.keys(CHARACTERS_CONFIG).forEach(key => {
            const char = CHARACTERS_CONFIG[key];
            const div = document.createElement('div');
            div.className = 'char-card';
            const pc = document.createElement('canvas');
            pc.width=50; pc.height=50;
            const pctx = pc.getContext('2d');
            // Preview usando el ancho de columna fijo (8) para que la cara salga bien
            const fw = processedImages[key].width / 8;
            pctx.drawImage(processedImages[key], 0, 0, fw, fw, 0, 0, 200, 200); 
            div.innerHTML = `<div class="char-preview" style="background-image:url(${pc.toDataURL()})"></div><span>${char.name}</span>`;
            div.onclick = () => selectChar(key);
            grid.appendChild(div);
        });
    }

    let p1Sel = null;
    function selectChar(k) {
        if(!p1Sel) {
            p1Sel = k;
            document.getElementById('select-instruction').innerText = "JUGADOR 2";
        } else {
            document.getElementById('character-select').style.display = 'none';
            startGame(p1Sel, k);
        }
    }

    function startGame(k1, k2) {
        document.getElementById('game-ui').style.display = 'block';
        document.getElementById('mobile-controls').style.display = 'block';
        
        const c1 = CHARACTERS_CONFIG[k1];
        const c2 = CHARACTERS_CONFIG[k2];

        document.getElementById('p1-name').innerText = c1.name;
        document.getElementById('p2-name').innerText = c2.name;

        player = new Fighter({
            position: {x: 200, y: 0}, velocity: {x:0, y:0},
            image: processedImages[k1], scale: c1.scale, offset: c1.offset, name: c1.name, direction: 1
        });
        enemy = new Fighter({
            position: {x: 800, y: 0}, velocity: {x:0, y:0},
            image: processedImages[k2], scale: c2.scale, offset: c2.offset, name: c2.name, direction: -1
        });

        gameRunning = true;
        decreaseTimer();
        animate();
    }

    function decreaseTimer() {
        if(timer>0 && gameRunning) {
            timerId = setTimeout(decreaseTimer, 1000);
            timer--;
            document.querySelector('.timer').innerText = timer;
        }
        if(timer===0) endGame();
    }

    function rectCol(r1, r2) {
        return (r1.attackBox.position.x + r1.attackBox.width >= r2.position.x &&
                r1.attackBox.position.x <= r2.position.x + r2.width &&
                r1.attackBox.position.y + r1.attackBox.height >= r2.position.y &&
                r1.attackBox.position.y <= r2.position.y + r2.height);
    }

    function endGame() {
        gameRunning = false;
        clearTimeout(timerId);
        document.getElementById('displayText').style.display = 'block';
        const txt = document.getElementById('winnerText');
        if(player.health === enemy.health) txt.innerText = "EMPATE";
        else if(player.health > enemy.health) txt.innerText = "P1 GANA";
        else txt.innerText = "P2 GANA";
    }

    function animate() {
        if(!gameRunning) return;
        window.requestAnimationFrame(animate);

        c.clearRect(0,0,canvas.width, canvas.height);
        drawBackground();

        // Orientación automática
        if(player && enemy) {
            if(player.position.x < enemy.position.x) { player.direction = 1; enemy.direction = -1; }
            else { player.direction = -1; enemy.direction = 1; }
        }

        player.update();
        enemy.update();

        // P1 Movimiento
        player.velocity.x = 0;
        if(keys.a.pressed) { player.velocity.x = -5; player.switchSprite(1); }
        else if(keys.d.pressed) { player.velocity.x = 5; player.switchSprite(1); }
        else player.switchSprite(0);

        // P2 Movimiento
        enemy.velocity.x = 0;
        if(keys.ArrowLeft.pressed) { enemy.velocity.x = -5; enemy.switchSprite(1); }
        else if(keys.ArrowRight.pressed) { enemy.velocity.x = 5; enemy.switchSprite(1); }
        else enemy.switchSprite(0);

        // Colisiones
        if(rectCol(player, enemy) && player.isAttacking && player.framesCurrent===2) {
            enemy.takeHit();
            player.isAttacking = false;
            document.getElementById('enemyHealth').style.width = enemy.health + '%';
        }
        if(player.isAttacking && player.framesCurrent===2) player.isAttacking=false;

        if(rectCol(enemy, player) && enemy.isAttacking && enemy.framesCurrent===2) {
            player.takeHit();
            enemy.isAttacking = false;
            document.getElementById('playerHealth').style.width = player.health + '%';
        }
        if(enemy.isAttacking && enemy.framesCurrent===2) enemy.isAttacking=false;

        if(player.health<=0 || enemy.health<=0) endGame();
    }

    // Controles
    window.addEventListener('keydown', e => {
        if(!gameRunning) return;
        switch(e.key) {
            case 'd': keys.d.pressed=true; break;
            case 'a': keys.a.pressed=true; break;
            case 'w': if(player.velocity.y===0) player.velocity.y = -15; break;
            case ' ': player.attack(); break;
            
            case 'ArrowRight': keys.ArrowRight.pressed=true; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed=true; break;
            case 'ArrowUp': if(enemy.velocity.y===0) enemy.velocity.y = -15; break;
            case 'ArrowDown': enemy.attack(); break;
        }
    });
    window.addEventListener('keyup', e => {
        switch(e.key) {
            case 'd': keys.d.pressed=false; break;
            case 'a': keys.a.pressed=false; break;
            case 'ArrowRight': keys.ArrowRight.pressed=false; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed=false; break;
        }
    });

    // Touch
    const setupTouch = (id, action, val) => {
        const btn = document.getElementById(id);
        btn.addEventListener('touchstart', e => {
            e.preventDefault();
            if(!gameRunning) return;
            if(action === 'move') keys[val].pressed = true;
            if(action === 'jump' && player.velocity.y===0) player.velocity.y = -15;
            if(action === 'attack') player.attack();
        });
        btn.addEventListener('touchend', e => {
            e.preventDefault();
            if(action === 'move') keys[val].pressed = false;
        });
    };

    setupTouch('btn-left', 'move', 'a');
    setupTouch('btn-right', 'move', 'd');
    setupTouch('btn-jump', 'jump');
    setupTouch('btn-attack', 'attack');

    window.addEventListener('click', () => { if(!gameRunning && player) location.reload(); });

    loadAssets();
</script>
</body>
</html>


