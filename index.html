<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Amigos Kombat</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }
        body { background-color: #121212; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Press Start 2P', cursive; color: white; }
        #game-container { position: relative; width: 100%; max-width: 1024px; aspect-ratio: 16/9; background: black; box-shadow: 0 0 30px rgba(0,0,0,0.8); overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        
        /* UI ELEMENTS */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; padding: 20px; display: flex; flex-direction: column; pointer-events: none; z-index: 10; display: none; }
        .top-bar { display: flex; align-items: center; justify-content: space-between; width: 100%; }
        .health-wrapper { display: flex; flex-direction: column; width: 42%; }
        .player-name { font-size: 12px; margin-bottom: 5px; text-shadow: 2px 2px black; }
        .health-bar-container { position: relative; width: 100%; height: 30px; background: #333; border: 3px solid #fff; }
        .health-bar { position: absolute; top: 0; height: 100%; background: #4ade80; transition: width 0.3s ease-out; }
        #playerHealth { left: 0; }
        #enemyHealth { right: 0; background: #f87171; }
        .timer { width: 50px; height: 50px; background: #222; border: 3px solid #fff; display: flex; justify-content: center; align-items: center; font-size: 20px; }
        .overlay-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 50px; display: none; z-index: 20; text-shadow: 4px 4px 0 #000; text-align: center; width: 100%; }
        .restart-hint { font-size: 12px; margin-top: 20px; animation: blink 1s infinite; display: block; }
        @keyframes blink { 50% { opacity: 0; } }

        /* SELECTION SCREEN */
        #character-select { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(to bottom, #1a1a2e, #16213e); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        #character-select h2 { margin-bottom: 10px; font-size: 24px; text-align: center; color: #e94560; text-shadow: 2px 2px 0 #000; }
        .selection-step { margin-bottom: 20px; text-align: center; font-size: 14px; color: #aaa; }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-width: 500px; width: 100%; }
        .char-card { background: rgba(255,255,255,0.1); border: 3px solid #444; padding: 10px; text-align: center; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; }
        .char-card:hover { background: rgba(255,255,255,0.2); border-color: #e94560; transform: scale(1.05); }
        .char-preview { width: 50px; height: 50px; background-repeat: no-repeat; background-size: 400%; background-position: 0 0; image-rendering: pixelated; margin-bottom: 10px; }

        /* CONTROLS */
        #mobile-controls { position: absolute; bottom: 10px; left: 0; width: 100%; height: 140px; display: none; pointer-events: none; z-index: 50; padding: 0 20px; }
        .control-group { pointer-events: auto; display: flex; gap: 15px; }
        .left-controls { position: absolute; bottom: 20px; left: 20px; }
        .right-controls { position: absolute; bottom: 20px; right: 20px; }
        .btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; backdrop-filter: blur(2px); }
        .btn:active { background: rgba(255, 255, 255, 0.4); }
        .btn-big { width: 75px; height: 75px; background: rgba(233, 69, 96, 0.3); border-color: #e94560; }
        
        #loading-msg { font-size: 10px; color: #aaa; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="character-select">
            <h2>ELIGE TU LUCHADOR</h2>
            <p class="selection-step" id="select-instruction">Cargando texturas...</p>
            <div id="loading-msg">Procesando transparencia...</div>
            <div class="grid" id="char-grid" style="display:none;"></div>
        </div>

        <div class="ui-layer" id="game-ui">
            <div class="top-bar">
                <div class="health-wrapper">
                    <div class="player-name" id="p1-name">JUGADOR 1</div>
                    <div class="health-bar-container"><div class="health-bar" id="playerHealth"></div></div>
                </div>
                <div class="timer" id="timer">60</div>
                <div class="health-wrapper" style="align-items: flex-end;">
                    <div class="player-name" id="p2-name">JUGADOR 2</div>
                    <div class="health-bar-container"><div class="health-bar" id="enemyHealth"></div></div>
                </div>
            </div>
        </div>

        <div class="overlay-text" id="displayText">
            <span id="winnerText">GANADOR</span>
            <span class="restart-hint">Toca para reiniciar</span>
        </div>

        <canvas id="canvas"></canvas>

        <div id="mobile-controls">
            <div class="left-controls control-group">
                <div class="btn" id="btn-left">←</div>
                <div class="btn" id="btn-right">→</div>
            </div>
            <div class="right-controls control-group">
                <div class="btn btn-big" id="btn-attack">⚔️</div>
                <div class="btn" id="btn-jump">↑</div>
            </div>
        </div>
    </div>

    <script>
        // --- IMÁGENES ---
        // Asegúrate de que los archivos .png estén junto al html
        const CHARACTERS_CONFIG = {
            juan: { name: "juan", color: "#4ade80", src: "./images/juan.png", scale: 3.5, offset: {x: 120, y: 100} },
            fran: { name: "fran", color: "#ffffff", src: "./images/fran.png", scale: 3.5, offset: {x: 120, y: 100} },
            fede: { name: "fede", color: "#60a5fa", src: "./images/fede.png", scale: 3.5, offset: {x: 120, y: 100} },
            rodri: { name: "rodri", color: "#a78bfa", src: "./images/rodri.png", scale: 3.5, offset: {x: 120, y: 100} }
        };

        // --- SISTEMA DE PROCESADO DE IMAGEN (CHROMA KEY) ---
        // Esto elimina el fondo negro automáticamente
        const processedImages = {};

        function removeBackground(imageSrc) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imageSrc;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;
                    
                    // Recorremos pixel por pixel
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Si el pixel es muy oscuro (negro o gris muy oscuro), lo hacemos transparente
                        // Umbral de 30 para no borrar zapatos oscuros
                        if (r < 40 && g < 40 && b < 40) {
                            data[i + 3] = 0; // Alpha 0 (Transparente)
                        }
                    }
                    
                    ctx.putImageData(imgData, 0, 0);
                    const newSrc = canvas.toDataURL();
                    const newImg = new Image();
                    newImg.src = newSrc;
                    resolve(newImg);
                };
                img.onerror = reject;
            });
        }

        async function loadAllCharacters() {
            const keys = Object.keys(CHARACTERS_CONFIG);
            const promises = keys.map(async (key) => {
                try {
                    const config = CHARACTERS_CONFIG[key];
                    const img = await removeBackground(config.src);
                    processedImages[key] = img;
                } catch (e) {
                    console.error("Error cargando imagen de " + key, e);
                    // Fallback si falla la carga (ej. no encuentra archivo)
                    processedImages[key] = new Image(); 
                }
            });
            
            await Promise.all(promises);
            initSelectionScreen();
        }

        // --- JUEGO BASE ---
        const canvas = document.querySelector('canvas');
        const c = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 576;
        const gravity = 0.8;

        class Sprite {
            constructor({ position, image, scale = 1, framesMax = 1, offset = { x: 0, y: 0 } }) {
                this.position = position;
                this.image = image;
                this.scale = scale;
                this.framesMax = framesMax;
                this.framesCurrent = 0;
                this.framesElapsed = 0;
                this.framesHold = 8;
                this.offset = offset;
                this.rows = 5; 
                this.currentRow = 0; 
            }
            draw() {
                if(!this.image) return;
                const frameWidth = this.image.width / this.framesMax;
                const frameHeight = this.image.height / this.rows;
                c.drawImage(
                    this.image,
                    this.framesCurrent * frameWidth, this.currentRow * frameHeight,
                    frameWidth, frameHeight,
                    this.position.x - this.offset.x, this.position.y - this.offset.y,
                    frameWidth * this.scale, frameHeight * this.scale
                );
            }
            animateFrames() {
                this.framesElapsed++;
                if (this.framesElapsed % this.framesHold === 0) {
                    if (this.framesCurrent < this.framesMax - 1) this.framesCurrent++;
                    else this.framesCurrent = 0;
                }
            }
            update() { this.draw(); this.animateFrames(); }
        }

        class Fighter extends Sprite {
            constructor({ position, velocity, image, scale = 1, framesMax = 1, offset = { x: 0, y: 0 }, name }) {
                super({ position, image, scale, framesMax, offset });
                this.velocity = velocity;
                this.width = 50; this.height = 150;
                this.lastKey;
                this.attackBox = { position: { x: this.position.x, y: this.position.y }, offset: { x: 100, y: 50 }, width: 160, height: 50 };
                this.isAttacking = false;
                this.health = 100;
                this.framesHold = 6;
                this.dead = false;
                this.name = name;
                this.facingRight = true; // Nuevo: control de dirección
            }

            update() {
                this.draw();
                if (!this.dead) this.animateFrames();
                
                // Dirección de ataque
                const attackOffsetX = this.facingRight ? 100 : -170; 
                this.attackBox.position.x = this.position.x + attackOffsetX; // Simplificado
                this.attackBox.position.y = this.position.y + 50;

                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                if (this.position.y + 150 + this.velocity.y >= canvas.height - 96) {
                    this.velocity.y = 0;
                    this.position.y = 330;
                } else this.velocity.y += gravity;

                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x + 50 > canvas.width) this.position.x = canvas.width - 50;
            }

            attack() {
                this.switchSprite('attack1');
                this.isAttacking = true;
            }
            takeHit() {
                this.health -= 10;
                if (this.health <= 0) this.switchSprite('death');
                else this.switchSprite('takeHit');
            }
            switchSprite(sprite) {
                if (this.currentRow === 4 && this.framesCurrent === this.framesMax - 1 && this.dead) return; // Dead logic
                if (this.currentRow === 2 && this.framesCurrent < this.framesMax - 1) return; // Attack logic
                if (this.currentRow === 4 && this.framesCurrent < this.framesMax - 1 && !this.dead) return; // Hit logic

                switch (sprite) {
                    case 'idle': if (this.currentRow !== 0) { this.currentRow = 0; this.framesMax = 4; this.framesCurrent = 0; } break;
                    case 'run': if (this.currentRow !== 1) { this.currentRow = 1; this.framesMax = 8; this.framesCurrent = 0; } break;
                    case 'attack1': if (this.currentRow !== 2) { this.currentRow = 2; this.framesMax = 4; this.framesCurrent = 0; } break; // Ajustado a sprites generados
                    case 'takeHit': if (this.currentRow !== 4) { this.currentRow = 4; this.framesMax = 3; this.framesCurrent = 0; } break;
                    case 'death': if (this.currentRow !== 4) { this.currentRow = 4; this.framesMax = 3; this.framesCurrent = 0; this.dead = true;} break;
                }
            }
        }

        let player, enemy, timer = 60, timerId, gameRunning = false;
        const keys = { a: { pressed: false }, d: { pressed: false }, ArrowRight: { pressed: false }, ArrowLeft: { pressed: false } };

        function initSelectionScreen() {
            document.getElementById('loading-msg').style.display = 'none';
            document.getElementById('select-instruction').innerText = "Jugador 1: Elige Personaje";
            const grid = document.getElementById('char-grid');
            grid.style.display = 'grid';
            grid.innerHTML = '';

            Object.keys(CHARACTERS_CONFIG).forEach(key => {
                const char = CHARACTERS_CONFIG[key];
                const card = document.createElement('div');
                card.className = 'char-card';
                
                // Usamos la imagen procesada para el preview
                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 50; previewCanvas.height = 50;
                const pCtx = previewCanvas.getContext('2d');
                // Dibujar solo la cara (aproximado)
                pCtx.imageSmoothingEnabled = false;
                pCtx.drawImage(processedImages[key], 0, 0, 50, 50, 0, 0, 200, 200); // Zoom
                
                card.innerHTML = `
                    <div class="char-preview" style="background-image: url(${previewCanvas.toDataURL()})"></div>
                    <span>${char.name}</span>
                `;
                card.onclick = () => selectCharacter(key);
                grid.appendChild(card);
            });
        }

        let p1Selection = null;
        function selectCharacter(key) {
            if (!p1Selection) {
                p1Selection = key;
                document.getElementById('select-instruction').innerText = "Jugador 2: Elige Oponente";
            } else {
                document.getElementById('character-select').style.display = 'none';
                startGame(p1Selection, key);
            }
        }

        function startGame(p1Key, p2Key) {
            const p1Data = CHARACTERS_CONFIG[p1Key];
            const p2Data = CHARACTERS_CONFIG[p2Key];

            document.getElementById('game-ui').style.display = 'flex';
            document.getElementById('p1-name').innerText = p1Data.name;
            document.getElementById('p2-name').innerText = p2Data.name;

            player = new Fighter({
                position: { x: 100, y: 0 }, velocity: { x: 0, y: 0 },
                image: processedImages[p1Key], scale: p1Data.scale, offset: p1Data.offset,
                framesMax: 4, name: p1Data.name
            });
            player.facingRight = true;

            enemy = new Fighter({
                position: { x: 800, y: 0 }, velocity: { x: 0, y: 0 },
                image: processedImages[p2Key], scale: p2Data.scale, offset: p2Data.offset,
                framesMax: 4, name: p2Data.name
            });
            enemy.facingRight = false; // Empieza mirando izq (aunque el sprite mire derecha, lo invertiremos en draw si hiciera falta, por ahora simple)

            // Reset UI
            player.health = 100; enemy.health = 100;
            document.getElementById('playerHealth').style.width = '100%';
            document.getElementById('enemyHealth').style.width = '100%';
            timer = 60; gameRunning = true;
            document.getElementById('displayText').style.display = 'none';
            
            decreaseTimer();
            animate();
            if('ontouchstart' in window || navigator.maxTouchPoints > 0) document.getElementById('mobile-controls').style.display = 'block';
        }

        function rectangularCollision({ rectangle1, rectangle2 }) {
            return (
                rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x &&
                rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width &&
                rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
                rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
            );
        }

        function determineWinner({ player, enemy, timerId }) {
            clearTimeout(timerId);
            document.querySelector('#displayText').style.display = 'flex';
            const txt = document.querySelector('#winnerText');
            if (player.health === enemy.health) txt.innerText = 'EMPATE';
            else if (player.health > enemy.health) txt.innerText = player.name + ' GANA';
            else txt.innerText = enemy.name + ' GANA';
            gameRunning = false;
        }

        function decreaseTimer() {
            if (timer > 0) { timerId = setTimeout(decreaseTimer, 1000); timer--; document.querySelector('#timer').innerHTML = timer; }
            if (timer === 0) determineWinner({ player, enemy, timerId });
        }

        function animate() {
            if(!gameRunning) return;
            window.requestAnimationFrame(animate);
            c.fillStyle = 'black'; c.fillRect(0, 0, canvas.width, canvas.height);
            
            // Fondo
            let gradient = c.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#201A30"); gradient.addColorStop(1, "#383050");
            c.fillStyle = gradient; c.fillRect(0, 0, canvas.width, canvas.height);
            c.fillStyle = '#111'; c.fillRect(0, canvas.height - 96, canvas.width, 96);

            player.update();
            enemy.update();

            // P1 Movement
            player.velocity.x = 0;
            if (keys.a.pressed && player.lastKey === 'a') { player.velocity.x = -5; player.switchSprite('run'); player.facingRight = false; }
            else if (keys.d.pressed && player.lastKey === 'd') { player.velocity.x = 5; player.switchSprite('run'); player.facingRight = true; }
            else player.switchSprite('idle');
            if (player.velocity.y < 0) {} // Jump animation todo

            // P2 Movement
            enemy.velocity.x = 0;
            if (keys.ArrowLeft.pressed && enemy.lastKey === 'ArrowLeft') { enemy.velocity.x = -5; enemy.switchSprite('run'); enemy.facingRight = false; }
            else if (keys.ArrowRight.pressed && enemy.lastKey === 'ArrowRight') { enemy.velocity.x = 5; enemy.switchSprite('run'); enemy.facingRight = true; }
            else enemy.switchSprite('idle');

            // Colisiones
            if (rectangularCollision({ rectangle1: player, rectangle2: enemy }) && player.isAttacking && player.framesCurrent === 1) {
                enemy.takeHit(); player.isAttacking = false;
                document.querySelector('#enemyHealth').style.width = enemy.health + '%';
            }
            if (player.isAttacking && player.framesCurrent === 1) player.isAttacking = false;

            if (rectangularCollision({ rectangle1: enemy, rectangle2: player }) && enemy.isAttacking && enemy.framesCurrent === 1) {
                player.takeHit(); enemy.isAttacking = false;
                document.querySelector('#playerHealth').style.width = player.health + '%';
            }
            if (enemy.isAttacking && enemy.framesCurrent === 1) enemy.isAttacking = false;

            if (enemy.health <= 0 || player.health <= 0) determineWinner({ player, enemy, timerId });
        }

        window.addEventListener('keydown', (event) => {
            if(!player || player.dead || !gameRunning) return;
            switch (event.key) {
                case 'd': keys.d.pressed = true; player.lastKey = 'd'; break;
                case 'a': keys.a.pressed = true; player.lastKey = 'a'; break;
                case 'w': player.velocity.y = -15; break;
                case ' ': player.attack(); break;
                case 'ArrowRight': keys.ArrowRight.pressed = true; enemy.lastKey = 'ArrowRight'; break;
                case 'ArrowLeft': keys.ArrowLeft.pressed = true; enemy.lastKey = 'ArrowLeft'; break;
                case 'ArrowUp': enemy.velocity.y = -15; break;
                case 'ArrowDown': enemy.attack(); break;
            }
        });
        window.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'd': keys.d.pressed = false; break;
                case 'a': keys.a.pressed = false; break;
                case 'ArrowRight': keys.ArrowRight.pressed = false; break;
                case 'ArrowLeft': keys.ArrowLeft.pressed = false; break;
            }
        });
        window.addEventListener('click', () => { if(!gameRunning && player) location.reload(); });
        window.addEventListener('touchstart', (e) => { 
            // Prevenir reload si toca controles
            if(e.target.classList.contains('btn')) return;
            if(!gameRunning && player) location.reload(); 
        });

        // Touch Buttons
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnJump = document.getElementById('btn-jump');
        const btnAttack = document.getElementById('btn-attack');
        function addTouchListener(elem, code, type) {
            elem.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if(!gameRunning) return;
                if (type === 'move') { keys[code].pressed = true; player.lastKey = code; }
                else if (type === 'jump') player.velocity.y = -15;
                else if (type === 'attack') player.attack();
            }, { passive: false });
            elem.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (type === 'move') keys[code].pressed = false;
            });
        }
        addTouchListener(btnLeft, 'a', 'move');
        addTouchListener(btnRight, 'd', 'move');
        addTouchListener(btnJump, 'w', 'jump');
        addTouchListener(btnAttack, 'space', 'attack');

        // START
        loadAllCharacters();

    </script>
</body>
</html>


